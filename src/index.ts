import {app, ipcMain, BrowserWindow} from "electron"
import {SerialPort} from "serialport"
import {PortInfo} from "@serialport/bindings-cpp"
import {ReadlineParser} from "@serialport/parser-readline"

/**
 * This allows TypeScript to pick up the magic constants that are auto-generated by the Forge Webpack
 * plugin, which tells the Electron app where to look for the Webpack-bundled app code (depending on
 * whether the runtime environment is development or production)
 */
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string


let port: SerialPort
let win: BrowserWindow

process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = "true" // disable security warnings in console

// handle creating/removing shortcuts on Windows when installing/uninstalling
if (require("electron-squirrel-startup")) {
    app.quit()
}

const createWindow = (): BrowserWindow => {
    // create the browser window
    const mainWindow = new BrowserWindow({
        height: 600,
        width: 800,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    })

    // load the index.html of the app.
    void mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

    // open the DevTools
    mainWindow.webContents.openDevTools({mode: "detach"})

    return mainWindow
}

function registerHandlers() {
    ipcMain.handle("get-ports", async (): Promise<PortInfo[]> => {
        return await SerialPort.list()
    })

    ipcMain.handle("set-port", (_, path: string, baudrate: number): boolean => {
        try {
            port = new SerialPort({
                path: path,
                baudRate: baudrate,
            })

            // port.on("data", (data: string) => {
            //     win.webContents.send("get-data", data)
            // })

            const parser = port.pipe(
                new ReadlineParser({delimiter: "\r\n", includeDelimiter: true})
            )
            parser.on("data", (data) => {
                console.log(data)
                win.webContents.send("get-data", data)
            })

            return port.isOpen
        } catch (err) {
            console.log(err)
        }
    })

    ipcMain.handle("send-data", (_, data): boolean => {
        console.log(data)
        return port.write(data)
    })

    ipcMain.on("close-port", (): void => {
        try {
            if (port.isOpen) port.close()
        } catch (err) {
            console.log(err)
        }
    })
}

/**
 * This method will be called when Electron has finished initialization and is ready to create browser windows
 * Some APIs can only be used after this event occurs!
 */
app.on("ready", () => {
    win = createWindow()

    registerHandlers()
})

/**
 * Quit when all windows are closed, except on OSX, where it is common for applications
 * and their menu bars to remain active until the user quits explicitly with Cmd + Q
 */
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        app.quit()
    }
})

app.on("activate", () => {
    /**
     * On OSX, it is common to re-create a window in the app when the
     * dock icon is clicked and there are no other windows open
     */
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow()
    }
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
